<html> 
<head> 
	<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
	<title>plane arium</title> 
	<style> body { margin: 0; } canvas { width: 100%; height: 100% } </style>
</head> 
<body>
<canvas id="c"></canvas>
  <script src="https://threejsfundamentals.org/threejs/resources/threejs/r105/three.min.js"></script>
<script src="https://threejsfundamentals.org/threejs/resources/threejs/r105/js/controls/OrbitControls.js"></script>
<script src="https://threejsfundamentals.org/threejs/../3rdparty/dat.gui.min.js"></script>	
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js" ></script>
<script> 

// Three.js - Cameras - Perspective
// from https://threejsfundamentals.org/threejs/threejs-cameras-perspective.html

$( document ).ready(function() {

    function main() {
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({canvas});

        const fov = 55;
        const aspect = 2;  // the canvas default
        const near = 0.1;
        const far = 10000;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(0, 0, 3);

        class MinMaxGUIHelper {
            constructor(obj, minProp, maxProp, minDif) {
                this.obj = obj;
                this.minProp = minProp;
                this.maxProp = maxProp;
                this.minDif = minDif;
            }
            get min() {
                return this.obj[this.minProp];
            }
            set min(v) {
                this.obj[this.minProp] = v;
                this.obj[this.maxProp] = Math.max(this.obj[this.maxProp], v + this.minDif);
            }
            get max() {
                return this.obj[this.maxProp];
            }
            set max(v) {
                this.obj[this.maxProp] = v;
                this.min = this.min;  // this will call the min setter
            }
        }

        function updateCamera() {
            camera.updateProjectionMatrix();
        }

        // const gui = new dat.GUI();
        // gui.add(camera, 'fov', 1, 180).onChange(updateCamera);
        // const minMaxGUIHelper = new MinMaxGUIHelper(camera, 'near', 'far', 0.1);
        // gui.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near').onChange(updateCamera);
        // gui.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far').onChange(updateCamera);

        const controls = new THREE.OrbitControls(camera, canvas);
        controls.target.set(0, 0, 0);
        controls.update();

        const scene = new THREE.Scene();
        scene.background = new THREE.Color('black');

        const color = 0xFFFFBB;
        const intensity = 1;
        const light = new THREE.PointLight(color, intensity);
        light.position.set(0, 0, 1000);
        scene.add(light);

        const ambient = new THREE.AmbientLight(0xFFFFFF, 0.3)
        scene.add(ambient);

        $.ajax({
            url: "/astres.json",
            dataType: "json",
            success: function(response) {
                for(name in response){
                    var o = response[name];
                    var sphereWidthDivisions = 32;
                    var sphereHeightDivisions = 16;
                    var sphereMat;
                    var sphereRadius = Math.log(o.info.mean_radius)/149.598000 ;
                    if(name == "Sun"){
                        light.position.set(o.ephemerids[0].x, o.ephemerids[0].z, o.ephemerids[0].y);
                        sphereMat = new THREE.MeshPhongMaterial({color: 0xCCAA88, emissive:0xCCAA88});
                    }
                    else{
                        sphereMat = new THREE.MeshPhongMaterial({color: 0x665544});
                    }
                    var sphereGeo = new THREE.SphereBufferGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);

                    var mesh = new THREE.Mesh(sphereGeo, sphereMat);
                    mesh.position.set(o.ephemerids[0].x, o.ephemerids[0].z, o.ephemerids[0].y);
                    mesh.name = name;

                    scene.add(mesh)
                }
            }
        });

        function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
                renderer.setSize(width, height, false);
            }
            return needResize;
        }

        function render() {
            if (resizeRendererToDisplaySize(renderer)) {
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
            }
            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    }


    main();

});

	</script> 
</body> 
</html>